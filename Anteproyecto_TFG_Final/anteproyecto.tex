%% ---------------------------------------------------------------------------
%% proposal.tex
%%
%% Research Proposal, main document.
%%
%% ---------------------------------------------------------------------------
\documentclass[12pt,letterpaper]{article}
% \usepackage[english]{babel}     % supports english, but default is
\usepackage[spanish,es-tabla]{babel}
% include this if you want to import graphics files with /includegraphics

\usepackage{longtable}
\usepackage{ifpdf}
\usepackage[table]{xcolor}

\usepackage{anysize}
\usepackage{textcomp}
\usepackage{url}
\bibliographystyle{unsrt}
\usepackage{graphics}
\usepackage{amssymb}
\usepackage{tabu}
\usepackage{graphicx}
%\usepackage{slashbox}
\usepackage[latin1]{inputenc}
\usepackage{tikz}
\usetikzlibrary{arrows,positioning}
\usetikzlibrary{shapes.geometric}
% Color and strikethrough

% For compactenum
\usepackage{paralist}

\usepackage[margin=0.9in]{geometry}
\usepackage{marginnote}

\usepackage{color}
\usepackage{soul}

\usepackage{array}
\usepackage{makecell}

\usepackage{sectsty}
\allsectionsfont{\sffamily}

\definecolor{dblue}{RGB}{0,102,153}
\newcommand{\dB}[1]{\textcolor{dblue}{\textbf{#1}}}



\setlength{\parskip}{1em}

% Nombre del Estudiante
\newcommand{\scriptAuthor}{Daniel Esteban Moya Sánchez}
 
% Tí­tulo de la tesis
\newcommand{\scriptTitle}{Diseño asistido de aplicaciones aproximadas para
sistemas computacionales personalizables}
\newcommand{\scriptEnglishTitle}{Assisted-Design of Approximate Applications for 
Customized Computational Systems}


% Keywords
\newcommand{\scriptKeywords}{key, words, ...}

% Para el PDF (cambiar si se desea otras cosas a lo indicado arriba
\newcommand{\pdfAuthor}{\scriptAuthor}
\newcommand{\pdfTitle}{\scriptTitle} 
\newcommand{\pdfKeywords}{\scriptKeywords}



\tikzset{
    mynode/.style={rectangle,rounded corners,draw=black, top color=white, bottom color=yellow!50,very thick, inner sep=1em, minimum size=3em, text centered},
    myarrow/.style={->, >=latex', shorten >=1pt, thick},
    mylabel/.style={text width=7em, text centered} 
} 

\begin{document}

\shorthandoff{>}\shorthandoff{<}
 
 \graphicspath{{./}{./fig/}}

 \input{./titlepage.tex}

  \tableofcontents

 \clearpage


 
%\section{Palabras Clave}

%Arquitectura heterogénea, Multi-aceleradores, Multi-núcleo, Caracterización, Calendarización, Computación aproximada, Calidad.
\section{Palabras Clave}
Computación aproximada, arquitectura heterogénea, caracterización, aceleradores 
aproximados.


\section{Introducción}

Los sistemas de Tecnologías de Información (TI) buscan dar una mejor calidad de
vida a las personas. En esta tarea, estos sistemas han tenido que enfrentar
ciertos problemas, entre ellos el costo en área, potencia y tiempo de ejecución, los cuales 
restringen el rendimiento de un chip. Idealmente, una aplicación debe ajustarse a las 
necesidades reales del usuario y, en general, del área de aplicación, de forma que se dé un 
uso óptimo de los recursos. Actualmente, el diseño de procesadores no solo se enfoca en
contar con más desempeño sino en tener un manejo de recursos apropiado. No
obstante, algunos desafíos en este campo están dados por limitaciones físicas,
por ejemplo:

\begin{compactitem}
 \item las características eléctricas de los transistores CMOS, las cuales
 restringen el consumo de energía en sistemas embebidos y lo cual es un aspecto
 que deben considerar los diseñadores de componentes para propósito
 específico en procesadores;

 \item la pared de memoria, que corresponde a la diferencia entre el crecimiento
 de la capacidad de procesamiento contra la velocidad de obtención de datos
 desde la memoria;

 \item y la pared de utilización, la cual limita el uso simultáneo máximo de hardware
  debido a las capacidades de disipación de calor en un sistema.
\end{compactitem}

Para poder enfrentar los problemas mencionados anteriormente, un área de
investigación actual corresponde a \emph{computación aproximada}, un
paradigma de diseño que propone una reducción en la precisión o exactitud de
la computación para obtener oportunidades de mejora en cuanto al consumo de
área, potencia y tiempo de ejecución. Para aplicar dicho paradigma es necesario
identificar aplicaciones tolerantes a errores y determinar, más específicamente,
cuáles secciones o funciones dentro de estas pueden ser sustituidas por
versiones aproximadas, de forma que se pueda generar un balance entre la calidad
de la salida y el consumo general de recursos.


Este documento busca explicar los detalles relacionados a la propuesta de un 
anteproyecto para el diseño asistido de aplicaciones aproximadas en sistemas 
computacionales personalizables, considerando una plataforma con multiples aceleradores 
de hardware disponibles. Con la realización del proyecto se espera constribuir a la 
investigación en el campo de la computación aproximada, especialmente en el Instituto 
Tecnológico de Karlsruhe en Alemania, así como en el área de ingeniería en 
computadores en general.

En la siguiente sección se presenta el contexto y los antecedentes del proyecto, que 
incluye una descripción de la institución donde se realizará el trabajo final de graduación y 
el área de conocimiento específica de este. Seguidamente, se realiza la justificación del 
problema, la especificación  de los objetivos, la mención de los beneficios y beneficiarios 
con los resultados del proyecto, los supuestos y limitaciones sobre los que parte el 
proyecto y un análisis de riesgos del mismo. Finalmente, se detalla la metodología que se 
seguirá en el proyecto, la cual incluye la tipificación del trabajo, descripción de las tareas 
que se realizarán, las herramientas que se utilizarán, los entregables que se fijan para 
cumplir con los objetivos propuestos, las estrategias de verificación y validación que se 
seguirán y, por último, el cronograma de trabajo propuesto. 


\section{Contexto y Antecedentes}

\subsection{Descripción de la Institución}

El Instituto Tecnológico de Karlsruhe (KIT) surge en 2009 a partir de la fusión
de la Universidad de Karlsruhe, fundada en 1825 como Universidad Fridericiana, y
el Centro de Investigación de Karlsruhe. Se ubica en Karlsruhe, Baden-Wüttemberg, al 
suroeste de Alemania. 

El KIT es una de las universidades técnicas más prestigiosas de Alemania, la cual
se especializa en ciencias de la ingeniería. Según \cite{kitData} para el 2017 contó con 
25.495 estudiantes y 9.297 empleados. De acuerdo con \cite{kitOrganization} el KIT está 
divido en cinco divisiones:

\begin{itemize}
 \item División I: Biología, Química e Ingeniería de Procesos.
 
 \item División II: Informática, Economía y Sociedad.
 
 \item División III: Ingeniería Mecánica y Eléctrica.
 
 \item División IV: Ambiente Natural y Construido. 
 
 \item División V: Física y Matemática.
\end{itemize}


Las divisiones trabajan en aspectos de investigación, enseñanza e innovación. Los 
programas de investigación se organizan en programas  Helmholtz, donde se le da apoyo 
a las investigaciones multidisciplinarias. Los departamentos en el KIT son los responsables 
de la educación universitaria. La Figura \ref{fig:org} resume la organización que 
posee el KIT en el campo de ciencia.


\begin{figure}[t!]
\begin{center}
 \includegraphics[scale=0.31]{organization_KIT}
 \caption{Organización científica en el KIT (Tomado de \cite{kitOrganization}).}
 \label{fig:org}
 \end{center}
\end{figure}

El Instituto de Ingeniería en Computadores del KIT incluye grupos de trabajo
que abarcan los diferentes niveles de abstracción de sistemas computacionales.
En el \emph{Chair for Embedded Systems} (CES) se investigan diversos aspectos
relacionados con el diseño de sistemas embebidos, desde la confiabilidad de
circuitos hasta el manejo de potencia en sistemas multinúcleos.

El presente proyecto será desarrollado en el CES bajo la dirección del M.Sc. Jorge 
Castro-Godínez, ingeniero en electrónica, investigador y estudiante de doctorado, quien 
es egresado del Tecnológico de Costa Rica y posee más de tres años como investigador 
en el Instituto Tecnológico de Karlsruhe. 

\subsection{Área de Conocimiento}


El área de conocimiento principal del proyecto es computación aproximada (explicada 
brevemente en la sección de Contexto del Problema), la cual incluye aspectos tanto de 
software como de hardware, dado que involucra aspectos tanto de modificación del ISA 
como uso de ASIPs y aceleradores para la computación de ciertos algoritmos. Las 
áreas de conocimiento de ingeniería que se tratan son: conocimiento sobre aspectos de 
arquitectura y micro-arquitectura de procesadores (por lo mencionado anteriormente), 
desarrollo de compiladores, dado que se modificará el \emph{frontend} de un compilador 
(Clang), finalmente, análisis de posibles aproximaciones de algoritmos en código escritos 
en el lenguaje de programación C, donde se espera agregar identificadores a las funciones 
que se busquen aproximar, para posteriormente ser procesadas de manera especial en la 
representación intermedia del código que se genere.


\section{Descripción de la Propuesta}

\subsection{Justificación y Definición del Problema}

\subsubsection{Contexto del Problema}

En la actualidad, dada la gran cantidad de aplicaciones complejas (por ejemplo
sistemas GPS, reconocimiento de voz, etc.), la computación aproximada ayuda a
mantener una salida aceptable mientras se logra que ciertas métricas como tiempo
de ejecución o eficiencia energética se mejoren. En general, la computación 
aproximada provee la libertad de escoger entre un cierto nivel de error o
degradación de la calidad en la salida final de una aplicación (por ejemplo
ruido en la señal de la salida) para mejorar el consumo de energía, el área o el
tiempo de ejecución; esto sirve como herramienta a un investigador para que ajuste
una aplicación dada a las necesidades reales y específicas de esta. En la Figura
\ref{fig:ap} se muestra un esquema que puede ser aplicado a sistemas tolerantes
a errores para incluir en estos la computación aproximada \cite{xu2018approximate}.


\begin{figure}[t!]
\begin{center}
 \includegraphics[scale=0.3]{APframework}
 \caption{Un marco de trabajo para el uso de computación aproximada (Tomado de
 \cite{xu2018approximate}).}
 \label{fig:ap}
 \end{center}
\end{figure}


Los elementos clave de la Figura \ref{fig:ap} son \emph{kernels} aproximados,
los cuales representan la implementación (técnicas) de las funciones
aproximadas, estas puede ser realizadas a nivel de hardware o de software; la
identificación de la secciones tolerantes a errores y sus características
particulares (análisis de impacto); y el manejo de la calidad, el cual implica
una evaluación continua para determinar si la aplicación logra los
requerimientos deseados.

Como se mencionó, la computación aproximada puede ser implementada tanto a nivel
de software como de hardware. En software una implementación típica es a través
de \emph{Loop Perforation}, en la cual ciertos ciclos (usualmente con un patrón
dado, como por ejemplo los pares) no son computados, lo cual, por ejemplo en una
aplicación de cálculo numérico, reduciría la precisión del valor final
calculado. A nivel de hardware, se pueden utilizar módulos especializados, por
ejemplo aceleradores para programas aproximados utilizando redes neuronales.

%REVISAR
El graduado de la carrera Ingeniería en Computadores Juan Carlos Cruz, realizó
un trabajo sobre la computación aproximada, donde él se dio la tarea de
caracterizar aplicaciones tolerantes a errores. Se busca partir de lo que Cruz
trabajó y usar el conocmiento de qué versión aproximada es la correcta
para entonces, a través de la modificación de Clang, generar un nuevo código 
C con las sustituciones correspondientes.



\subsubsection{Especificación del Problema}

Al contar con una aplicación que presenta una estructura en \emph{pipeline}, es decir, que 
posee una serie de etapas, donde cada etapa recibe su entrada de una etapa anterior y 
produce una salida para la etapa siguiente, y donde una o más etapas pueden ser 
aproximables con más de una versión aproximable (una versión se puede concentrar en 
mejorar el consumo de potencia, mientras que otra el tiempo de ejecución, por ejemplo) 
resulta complejo determinar qué combinación de versiones aproximadas utilizar de forma 
que no se sobrepase el error máximo permitido y a la vez se reduzca, de manera óptima, el 
uso de ciertos recursos. Dicho proceso podría tomar una cantidad considerable de tiempo 
si se decide probar todas las posibles combinaciones posibles de versiones aproximadas, 
por lo que es importante utilizar un esquema de trabajo diferente.

Una aplicación puede tener un comportamiento aproximado si alguna de sus etapas se 
puede aproximar, ya sea toda una sección o únicamente una función (dentro de una 
sección). La Figura \ref{fig:problem} muestra como ejemplo una aplicación genérica donde 
ambas situaciones pueden ocurrir. En esta aplicación se tienen tres
secciones, de las cuales la primera (por ejemplo, una etapa de preprocesamiento)
puede ser completamente aproximada, la segunda no puede ser aproximada del todo 
(por ejemplo, una sección crítica de la aplicación) y, finalmente, la tercera
tiene tres funciones específicas, de las cuales únicamente la segunda posee
una versión aproximada.


\begin{figure}[t!]
\centering
\begin{tikzpicture}[node distance=1cm, auto]  
\tikzset{
    mynode/.style={rectangle,rounded corners,draw=black, very thick, minimum
    size=3em, text centered},
    myarrow/.style={->, >=latex', shorten >=1pt, thick},
    mylabel/.style={text width=7em, text centered} 
}  
\node[mynode] (manufacturer) {Aplicación};  
\node[mynode, below left =3cm of manufacturer] (section1) {Sección 1}; 
\node[mynode, below=2.16cm of manufacturer] (section2) {Sección 2};
\node[mynode, below right=3cm of manufacturer] (section3) {Sección 3};

\node[mynode, below=1cm of section1, dashed] (comment1) {\makecell{Toda esta
sección \\ puede ser aproximada}};

\node[mynode, below left=3cm of section3] (instru1) {Función 1};
\node[mynode, below =2.16cm of section3] (instru2) {Función 2};
\node[mynode, below right=3cm of section3] (instru3) {Función 3};

\node[mynode, below=1cm of instru2, dashed] (comment2) {\makecell{Esta
función específica\\ puede ser reemplazada por \\ una versión aproximada}};


\draw[myarrow] (manufacturer.south)  -- ++(0,-1) -|  (section1.north);
\draw[myarrow] (manufacturer.south)   -|  (section2.north);
\draw[myarrow] (manufacturer.south)  -- ++(0,-1) -|  (section3.north); 

\draw[->, >=latex', shorten >=1pt, thick, dashed]  (comment1.north) -|  (section1.south); 

\draw[myarrow] (section3.south)  -- ++(0,-1) -|  (instru1.north);
\draw[myarrow] (section3.south)   -|  (instru2.north);
\draw[myarrow] (section3.south)  -- ++(0,-1) -|  (instru3.north); 
 
 \draw[->, >=latex', shorten >=1pt, thick, dashed]  (comment2.north) -|  (instru2.south); 
 
\end{tikzpicture} 
\medskip
\caption{Una posible aplicación aproximada genérica analizada en este proyecto.} 
\label{fig:problem}
\end{figure}



En el caso hipotético de la Figura \ref{fig:problem} donde se tenga más de una
versión aproximada para la sección 1 y para la función 2 de la sección 3,
es dificulta determinar qué combinación de versiones aproximadas produce la mejor 
aplicación aproximada final, debido a que, por ejemplo, un cambio en la sección 1 puede 
impactar severamente las secciones 2 y 3, pues dicha complejidad aumenta con la 
cantidad de versiones aproximadas; inclusive, puede que la versión aproximada de la 
función 2 determine qué tipo de versiones aproximadas son las más convenientes 
(según las especificaciones del usuario) en la sección 1 para no impactar en gran medida 
la calidad de la aplicación. 

%REVISAR
Actualmente, existe una manera preliminar de hacer la exploración y determinar
qué versión de una sección corresponde a ser utilizada según las restricciones
del usuario; no obstante, no existe una herramienta que permita ingresar un código C con anotaciones
propias y que, a partir de este, genere un nuevo código con las sustituciones correspondientes;
es decir, una marco de trabajo más completo.


\subsubsection{Justificación de la Necesidad}

Debido a la creciente necesidad por un consumo eficiente de recursos, ya sea energía,
área o tiempo de ejecución, la computación aproximada, como alternativa de solución 
a este problema, se considera considerablemente importante. El diseño de un marco
de trabajo para la realización de aplicaciones personalizadas mediante el uso de 
computación aproximada puede traer nuevos conocimientos a esta área de investigación y 
potenciar la creación de más aplicaciones, especializadas según los requerimientos
específicos de los usuarios. 

Con este proyecto, el conocimiento generado en Alemania se puede traer para obtener 
grandes beneficios en Costa Rica, de tal forma que se incentive la investigación, e 
inclusive una posible inversión en esta área. Actualmente no existe una herramienta 
académica que realice lo que se plantea en esta propuesta, por lo que se espera que el 
proyecto incentive otros proyectos en el área de generación de procesadores
con funciones especializadas. 


\subsection{Enfoque de la solución}


Se busca desarrollar una herramienta de software que pueda escoger entre
diferentes versiones para una aplicación aproximada (cada versión dada por una
combinación diferente de versiones específicas para cada sección aproximable) y
que como producto genere un nuevo código ejecutable,
según el criterio de usuario que especifique cuáles recursos son críticos en
la aplicación y cuál es la cantidad máxima de error permitido. La Figura 
\ref{fig:sol} muestra una abstracción de la implementación de esta herramienta.

%REVISAR
\begin{figure}[t!]
\centering
\resizebox{\textwidth}{!}{\begin{tikzpicture}[node distance=1cm, auto]  
\tikzset{
    mynode/.style={rectangle,rounded corners,draw=black, very thick, minimum
    size=3em, text centered},
    myarrow/.style={->, >=latex', shorten >=1pt, thick},
    mylabel/.style={text width=7em, text centered} 
}  
\node[mynode] (codfuente) {\makecell{Código fuente en C con anotaciones}};
\node[mynode, below =2cm of codfuente] (extraccion) {\makecell{Procesamiento de\\ código con \\modificaciones a Clang}}; 


\draw[myarrow] (codfuente.south)  -|  (extraccion.north);

\draw (12.4,1) ellipse (1.25 and 0.2);
\draw (11.15,1) -- (11.15,-0.5);
\draw (11.15,-0.5) arc (180:360:1.25 and 0.2);
\draw (13.65,-0.5) -- (13.65,1);  

\node[] at (12.4,0) (bd) {\makecell{Modelos de\\aceleradores}}; 

\node[] at (8.9,0) (qc) {\makecell{Restricción de\\calidad}}; 

\node[mynode, right = 1cm of extraccion] (deterVersiones) {\makecell{Creación de árbol\\ de llamadas y generación\\ de representación intermedia}};

\draw[myarrow] (extraccion.east)  ->  (deterVersiones.west);


\node[mynode, right = 1cm of deterVersiones] (confHardware) {
\makecell{Sustitución de código\\ y uso de funciones\\ aproximadas}};

\draw[myarrow] (12.4,-0.7)  -|  (confHardware.55);

\draw[myarrow] (8.9,-0.7) -- (8.9,-1.1)  -|  (confHardware.120);

\draw[myarrow] (deterVersiones.east)  ->  (confHardware.west);

\node[mynode, right = 1.5cm of confHardware] (final) {Nuevo código C};

\draw[myarrow] (confHardware.east)  ->  (final.west);

\draw[dashed] (-3,-5) -- (-3,-1.5) -- (14.5,-1.5) -- (14.5,-5) -- (-3,-5) ;

\end{tikzpicture}}
\medskip
\caption{Esquema general de la solución propuesta.} 
\label{fig:sol}
\end{figure}

%REVISAR
Como se muestra en la Figura \ref{fig:sol}, se espera recibir un código fuente
de una aplicación aproximable, donde previamente el usuario ha indicado, a
través de pragmas propios, qué funciones del código son tolerantes a errores; este
es transformado a una representación intermedia, el cual consistirá de un árbol (o la
estructura que se considere apropiada) con las llamadas de las funciones. Se toma el
algoritmo desarrollado por Juan Carlos Cruz para poder escoger cuáles versiones
aproximadas de las posibles que existen se ajustan para cumplir a cabalidad con
el error permitido (restricción de calidad) y, de la mejor manera, con la 
priorización de recursos. Una vez identificadas las versiones que serán utilizadas,
se procederá a sustituir el código específico que cuente con el soporte para
las funciones aproximadas correspondientes, utilizando modelos funcionales
de aceleradores, los cuales son representaciones a nivel de software del
hardware especialmente. Como producto final, se espera entregar una nuevo código fuente
con todas las sustituciones correspondientes.


\subsection{Especificación de Objetivos}

\subsubsection{Objetivo General}
%REVISAR
Desarrollar una herramienta que, a partir un algoritmo que determina cuáles
versiones de secciones aproximadas corresponden en cierta aplicación, pueda
generar una representación intermedia del código para finalmente generar
una versión modificada del mismo. 



\subsubsection{Objetivos Específicos}

\begin{enumerate}
 \item Modificar el \emph{frontend} (Clang) de un compilador de forma que se reconozca  
 anotaciones propias que se agreguen en el código para establecer qué funciones son  
 aproximables.

 %REVISAR
 \item Abstraer el código de la representación intermedia a un árbol de llamadas
 o la estructura que se considere apropiada, que tome en cuenta las anotaciones
 dadas por el usuario.
 
 \item Implementar el algoritmo propuesto para la exploración del espacio de diseño
 de posibles versiones de secciones aproximadas (aporte de Juan Carlos) en la herramienta
 a desarrollar.
 
 \item Generar una nueva versión de código ejecutable donde las anotaciones
 sean sustituidas por los aceleradores o versiones aproximadas correspondientes.
 

 
 %\item Verificar que la aplicación final aproximada cumpla con el funcionamiento
 %de la aplicación original y las restricciones dadas por el usuario de la
 %aplicación.
\end{enumerate}





\subsection{Beneficios y Beneficiarios con la Propuesta}

\begin{enumerate}
 \item Daniel Esteban Moya Sánchez: Se podrán fortalecer los conocimientos de 
 arquitectura en computadores, compiladores, y aproximaciones a nivel de hardware y 
 software, todo esto en un ambiente internacional, el cual aumentará el panorama cultural 
 que se tiene, con los  beneficios personales que esto conlleva.  Se espera cunplir con los 
 requerimientos del curso CE5600 Trabajo Final de Graduación, para así completar el plan 
 de estudios 2100 de la carrera de Ingeniería en Computadores y poder graduarse para el 
 año 2019. 
 
 \item Jorge Alberto Castro Godínez: Profesor tutor en el KIT, Alemania. Es investigador y 
 estudiante de doctorado, a cargo de varios proyectos en el CES. Dentro de los beneficios 
 está el conocimiento que se genere debido al intercambio de ideas y resultados del 
 proyecto, que ampliarán las habilidades técnicas tanto a nivel de hardware como de 
 software. 
 
 \item Chair for Embedded Systems (CES): Corresponde al lugar específico en el KIT donde 
 se estará llevando a cabo el proyecto. El proyecto propuesto podrá formar parte de la 
 investigación en el CES, lo cual beneficia parte de las áreas de investigación que trata. Se 
 espera que los resultados del proyecto incentiven nuevos proyectos y aumenten así el 
 conocimiento en el área de computación aproximada.
 
 
 \item Instituto Tecnológico de Costa Rica: Como parte de los principios de investigación y 
 extensión, para el TEC es sumamente importante la presencia de estudiantes en el 
 exterior. Los conocimientos que se generan a partir del proyecto propuesto podrán mejor 
 la investigación en el TEC, e incentivar el área de computación aproximada. 
\end{enumerate}


\subsection{Supuestos y Limitaciones}

\begin{enumerate}
\item Limitación de tiempo: El proyecto se debe completar en un periodo menor a 5 meses, 
específicamente del 1 de Julio al 20 de Noviembre del 2018, dado que se necesita regresar 
al país para realizar la defensa presencial del proyecto en el TEC, además de realizar los 
trámites correspondientes para la graduación del 2019. 

\item Disponibilidad de recursos: El proyecto se realizará utilizando herramientas de 
software libres. Para investigar se utilizará internet y el material disponible en el CES. 
Cualquier material físico del proyecto (como placa FPGA de desarrollo) será provisto por el 
CES de ser necesario.

\item Disponibilidad de versiones de funciones aproximadas y modelos de aceleradores:
El proyecto parte de la  existencia de diferentes versiones aproximadas de funciones en
aplicaciones tolerantes a errores, que se utilizarán en conjunto con los distintos modelos
de aceleradores como base para alimentar la herramienta propuesta.

\item Disponibilidad de algoritmo de exploración: El proyecto utilizará el algoritmo desarrollado
por Juan Carlos Cruz para la exploración de posibles versiones de secciones (o funciones) aproximadas,
el cual será implementado en la herramienta propuesta. 
\end{enumerate}


\subsection{Análisis de Riesgos}

En la Tabla \ref{tab:risk} se resumen los riesgos que se consideran para el proyecto.

\begin{table}[h!]
\begin{center}
\caption{Posibles riesgos del proyecto.} 
\resizebox{\textwidth}{!}{\begin{tabular}{|c|c|c|c|c|} 
 \hline
ID	&Descripción	&\makecell{Probabilidad\\ de ocurrencia}	&\makecell{Impacto\\ (horas)}	&Plan de Acción \\ \hline
1	&\makecell{Falta de disponibilidad de asesores para el\\ proyecto}	&0.2	&16	
&Aceptar \\ \hline
2	&\makecell{Carencia de materiales necesarios para el\\ proyecto}	&0.2	&8	&Evitar \\ \hline
3	&\makecell{Errores a la hora de modificar Clang}	&0.3	&12	&Mitigar \\ \hline
4	&\makecell{Dificultades a la hora de implementar \\algoritmo de exploración}	&0.4	&10	&Mitigar \\ \hline
\end{tabular}}
\label{tab:risk}
\end{center}
\end{table}

A continuación se explica cada riesgo detalladamente:

\begin{enumerate}
 \item Falta de disponibilidad de asesores para el proyecto: Corresponde a momentos en
 que, ya sea el supervisor Jorge Castro o el director de tesis
 no puedan atender alguna duda o simplemente no se encuentren disponibles en una semana 
 determinada, lo cual atrase la revisión del trabajo.
 
 \item Carencia de materiales necesarios para el proyecto: El atraso de la entrega o no
 la presencia de alguno de los materiales (información o programas de software principalmente) que se necesitan
 para realizar el proyecto, siendo el más importante las versiones aproximadas y los modelos
 de los aceleradores que se utilizarán. 
 
 \item Errores a la hora de modificar Clang: Problemas de dependencias o aceptación de las 
 modificaciones realizadas para el compilador de \emph{frontend} Clang. 
 
 \item Dificultades a la hora de implementar algoritmo de exploración: Problemas a la
 hora de entender y adaptar
 el algoritmo desarrollado por Juan Carlos Cruz en la herramienta propuesta.
 
\end{enumerate}

Los planes de acción se detallan a continuación:

\begin{enumerate}
 \item Aceptar: Asumir la responsabildidad correspondiente y continuar trabajando,
 con más cuidado inclusive y realizando un auto-análisis.
 
 \item Evitar: Definir apenas comience el proyecto los materiales y sus fuentes con 
 las que se contarán, de tal modo que se pueda contar con ellos (o al menos con una
 copia digitial) para evitar contratiempos de adquisición cuando se necesiten en el proyecto.
 
 \item Mitigar: Se realizará una investigación previa del \emph{frontend} Clang y se 
 realizarán  cambios iterativos, de tal forma que poco a poco se verifique las nuevas 
 funcionalidades que se agreguen a Clang. Por otro lado, para la implementación
 del algoritmo de exploración, este será estudiado previo a que inicie el proyecto
 propuesto y se realizarán las consultas respectivas al supervisor Jorge Castro
 a lo largo del proyecto.
 
\end{enumerate}



\section{Propuesta Metodológica}

\subsection{Tipificación del Trabajo}

El proyecto se clasifica como un trabajo de investigación aplicada, con alto porcentaje de 
experimentación. Esto se debe a que no existe ninguna herramienta que realice lo que se 
plantea y se busca incursionar en un campo relativamente nuevo (considerando la 
tecnología del país y la educación recibida hasta el momento), donde se espera que los 
resultados obtenidos inspiren nuevos proyectos en el área. 

\subsection{Descripción del Proceso}

%REVISAR
La Figura \ref{fig:proceso} resume el proceso que se realizará durante el proyecto.
Como se puede observar, el proyecto iniciará con una breve investigación  sobre 
maneras de modificar el compilador de \emph{frontend}
Clang para permitir el reconocimiento de pragmas o anotaciones personalizadas en el código.

\begin{figure}[t!]
\centering
\begin{tikzpicture}[node distance=1cm, auto]  
\tikzset{
    mynode/.style={rectangle,rounded corners,draw=black, very thick, minimum
    size=3em, text centered},
    myarrow/.style={->, >=latex', shorten >=1pt, thick},
    mylabel/.style={text width=7em, text centered} 
}  
\node[mynode] (investigacion) {Investigación sobre Clang y su modificación};

\node[mynode, below=1cm of investigacion] (compilador) {Modificación de compilador con pragmas propios};

\draw[myarrow] (investigacion.south)   -|  (compilador.north);

\node[mynode, below=1cm of compilador] (algoritmo) {\makecell{Estudio y programación de estructura de\\ datos para representación intermedia del código}};
 
 \draw[myarrow] (compilador.south)   -|  (algoritmo.north);
 
 
 \node[mynode, below=1cm of algoritmo] (verificacion) {Generación de versión final del código};
 
  
   \draw[<->, >=latex', shorten >=1pt, thick]  (algoritmo.south) -- (verificacion.north); 
  
 
  
  \node[mynode, right=1.8cm of investigacion, dashed] (ini) {Documentación};

  \node[mynode, right=2cm of verificacion] (fin) {Documentación final}; 
  
 
 \draw[->, >=latex', shorten >=1pt, thick, dashed]  (ini.south) -|  (fin.north); 

\end{tikzpicture} 
\medskip
\caption{Proceso a realizar en este proyecto.} 
\label{fig:proceso}
\end{figure}

%REVISAR
Seguidamente, se analizará qué estructura es la más apropiada para abstraer el código
recibido y generar una representación intermedia del mismo, de manera que sea fácilmente
manipulable y
considere las anotaciones dadas por el usuario. Para esta tarea
se tomará información de una base de datos del KIT sobre aceleradores, para finalmente
generar una nueva versión del código la cual contenga todos los detalles necesarios
para simplemente ejecutarse con las versiones de secciones aproximadas seleccionadas.

Se parte de que el algoritmo (desarrollado por Cruz) que determinará qué versión de sección aproximada permite cumplir
con los requerimientos del usuario con respecto al área, energía o calidad
estará disponible y se realizará la adaptación de dicho algoritmo
a la herramienta que se plantea desarrollar. 


La documentación del proyecto se trabajará a lo largo de todo el proceso de
desarrollo, de forma que al final se genere un artículo científico y demás
documentos propios de un trabajo final de graduación.



\subsection{Herramientas}

\begin{enumerate}
 \item Lenguaje de programación: El software desarrollado utilizará C/C++ como lenguaje de programación.
 
 \item Sistema operativo: Se utilizará Ubuntu 17.10.
 
 %REVISAR
 \item Compiladores: Se utilizarán los compiladores GCC/G++. Se modificará el compilador de \emph{frontend} Clang para
 incluir las anotaciones propias.
 
 \item Editor de texto: Para la documentación se utilizará LaTeX, con el ambiente de desarrollo Kile y compartido
 a través de Git. Para programar, se utilizará principalmente el editor en terminal Vim.
 
\end{enumerate}



\subsection{Descripción de Entregables}

La tabla \ref{tab:entrega} presenta la asociación entre entregables y objetivos del proyectos.


\begin{table}[h!]
\begin{center}
\caption{Entregables del proyecto}
\resizebox{\textwidth}{!}{\begin{tabular}{|c|c|} 
 \hline
Objetivo	&Entregable \\ \hline

\makecell{Modificar el compilador de front-end Clang de forma que se\\ reconozcan las anotaciones propias
que se agreguen en el \\código para establecer qué funciones son aproximables.}	&Compilador Clang modificado con pragmas propios \\ \hline
 \makecell{Abstraer el código de la representación intermedia a un \\árbol de llamadas o la estructura 
 que se considere apropiada,\\ que tome en cuenta las anotaciones dadas por el usuario}
 &\makecell{Código en representación de árbol de llamadas\\u otro tipo de representación según se determine} \\ \hline
  \makecell{Implementar el algoritmo propuesto para la exploración del\\ espacio de diseño de posibles 
  versiones de secciones \\aproximadas (aporte de Juan Carlos) en la herramienta a\\ desarrollar}
  &\makecell{Adaptación del algoritmo desarrollado en la\\ herramienta propuesta} \\ \hline 
 \makecell{Generar una nueva versión de código ejecutable donde\\ las anotaciones sean sustituidas por
 los aceleradores o \\versiones aproximadas correspondientes}	&\makecell{Código generado con anotaciones (pragmas)\\ sustituidas} \\ \hline
\end{tabular}}
\label{tab:entrega}
\end{center}
\end{table}


\subsection{Estrategias de Verificación y Validación}

Dado que se trata de un proyecto de investigación, cada uno de los entregables mencionados anteriormente tendrá un conjunto de pruebas
asociado, las cuales corresponden a:

\begin{itemize}
 \item Pruebas para compilador Clang: se empezará por verificar la correcta funcionalidad con un código sin anotaciones y se irán realizando pruebas unitarias para cada
 pragma nuevo que se agregue.
 
 \item Pruebas para el código en representación intermedia: se revisará manualmente que el código en esta interpretación sea correcto. 
 
 \item Pruebas de integración del algoritmo de exploración: el supervisor realizará una revisión de la funcionalidad del algoritmo
 una vez que se encuentre integrado con la herramienta propuesta. 
 
 \item Pruebas para el código final generado (con pragmas sustituidos): el supervisor probará el código y determinará si cumple 
 con los diferentes tipos de posibles requerimientos de un usuario.
\end{itemize}


Todas las pruebas mencionadas anteriormente serán llevadas a cabo mediante la supervisión de Jorge Castro y la contraparte en el TEC que se asigne. 



\subsection{Cronograma de Trabajo Propuesto}


Considerando los 4 meses (16 semanas) del semestre, el cronograma de trabajo para el proyecto propuesto se muestra en la tabla \ref{tab:schd}. 




\begin{table}[h!]
\begin{center}
\caption{Cronograma para el proyecto propuesto}
\resizebox{\textwidth}{!}{\begin{tabular}{ | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c |} 
 \hline
   & \multicolumn{16}{|c|}{Semana} \\
 \hline
 Actividad & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 \\ \hline
 \makecell{Modificación de Clang}
 & \cellcolor[HTML]{5B9BD5}  & \cellcolor[HTML]{5B9BD5} & \cellcolor[HTML]{5B9BD5}  & \cellcolor[HTML]{5B9BD5}  &  &  &  &  &  &  &  &  &  &  &  &  \\ \hline
 \makecell{Generación de representación \\intermedia}
 &   &  &   &   &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &  &  &  &  &  &  &  &  \\ \hline
  \makecell{Generación de código con\\ pragmas sustituidas \\(adaptación de algoritmo\\ de Juan Carlos)}
 &   &  &   &   &  &  &  & &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &  &  &  &  \\ \hline
 \makecell{Validación de la herramienta}
 &  &   &  &  &  &  &  &  &  &  &\cellcolor[HTML]{5B9BD5} &\cellcolor[HTML]{5B9BD5} &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &  &  \\ \hline
 \makecell{Documentación final} &  &   &  &  &  &  &  &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &
     \cellcolor[HTML]{5B9BD5} & \cellcolor[HTML]{5B9BD5} & \cellcolor[HTML]{5B9BD5} & \cellcolor[HTML]{5B9BD5} &  \\ \hline
  \makecell{Elaboración de presentación \\para la defensa del Trabajo \\Final de Graduación}
 &  &   &  &  &  &  &  &  &  &  &  &  &  &  & \cellcolor[HTML]{5B9BD5} & \cellcolor[HTML]{5B9BD5} \\ \hline
 \end{tabular}}
\label{tab:schd}
\end{center}
\end{table}



% Referencias del Background y el Related Work
\bibliographystyle{sty/plainurl}
\bibliography{references}

\newpage
\centerline{\large\bf Ingeniería en Computadores}
\par\vspace{2mm}
\centerline{\large\bf Ficha de contactos del proyecto}

\textbf{Datos del estudiante}

\begin{tabu} to \textwidth {| X[l] | X[l] |}	
 \hline
 Nombre	& Daniel Esteban Moya Sánchez \bigskip \\ \hline
 Correo electrónico	&danielmscr1994@gmail.com \bigskip \\ \hline
 Teléfonos	&(+506) 8325 9730 \bigskip \\ \hline
\end{tabu}

\par\vspace{8mm}


\textbf{Datos del proyecto}

\begin{tabu} to \textwidth {| X[l] | X[l] |}	
 \hline
 Nombre	&Diseño asistido de aplicaciones aproximadas para sistemas computacionales personalizables \bigskip \\ \hline
 Breve descripción	&Se desarrollará una herramienta que, a partir un algoritmo
 que determina cuáles versiones de secciones aproximadas corresponden en cierta 
 aplicación, se pueda generar una representación intermedia del código para finalmente generar
una versión modificada del código. \bigskip \\ \hline
 Fecha de inicio	&Lunes 2 de Julio del 2018 \bigskip \\ \hline
\end{tabu}


\par\vspace{8mm}


\textbf{Datos de la empresa u organización}

\begin{tabu} to \textwidth {| X[l] | X[l] |}	
 \hline
 Nombre	&Chair for Embedded Systems (CES), Instituto Tecnológico de Karlsruhe (KIT), Alemania \bigskip \\ \hline
 
 Nombre contacto	&Jorge Alberto Castro Godínez, M.Sc.\bigskip \\ \hline
 Correo electrónico	&jocastro@itcr.ac.cr \bigskip \\ \hline
 Teléfonos	&+49 721 608 48780 \bigskip \\ \hline
\end{tabu}

\end{document}

