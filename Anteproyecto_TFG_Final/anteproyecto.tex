%% ---------------------------------------------------------------------------
%% proposal.tex
%%
%% Research Proposal, main document.
%%
%% ---------------------------------------------------------------------------
\documentclass[12pt,letterpaper]{article}
% \usepackage[english]{babel}     % supports english, but default is
\usepackage[spanish,es-tabla]{babel}
% include this if you want to import graphics files with /includegraphics

\usepackage{longtable}
\usepackage{ifpdf}
\usepackage[table]{xcolor}

\usepackage{anysize}
\marginsize{2.5cm}{2.5cm}{1cm}{1cm}
\usepackage{textcomp}
\usepackage{url}
\bibliographystyle{unsrt}
\usepackage{graphics}
\usepackage{amssymb}
\usepackage{tabu}
\usepackage{graphicx}
%\usepackage{slashbox}
\usepackage[latin1]{inputenc}
\usepackage{tikz}
\usetikzlibrary{arrows,positioning}
\usetikzlibrary{shapes.geometric}
% Color and strikethrough

% For compactenum
\usepackage{paralist}

\usepackage{geometry}
\usepackage{marginnote}

\usepackage{color}
\usepackage{soul}

\usepackage{array}
\usepackage{makecell}

\usepackage{sectsty}
\allsectionsfont{\sffamily}

\definecolor{dblue}{RGB}{0,102,153}
\newcommand{\dB}[1]{\textcolor{dblue}{\textbf{#1}}}



\setlength{\parskip}{1em}

% Nombre del Estudiante
\newcommand{\scriptAuthor}{Daniel Esteban Moya Sánchez}
 
% Tí­tulo de la tesis
\newcommand{\scriptTitle}{Diseño asistido de aplicaciones aproximadas para
sistemas computacionales personalizables}
\newcommand{\scriptEnglishTitle}{Assisted-Design of Approximate Applications for 
Customized Computational Systems}


% Keywords
\newcommand{\scriptKeywords}{key, words, ...}

% Para el PDF (cambiar si se desea otras cosas a lo indicado arriba
\newcommand{\pdfAuthor}{\scriptAuthor}
\newcommand{\pdfTitle}{\scriptTitle} 
\newcommand{\pdfKeywords}{\scriptKeywords}



\tikzset{
    mynode/.style={rectangle,rounded corners,draw=black, top color=white, bottom color=yellow!50,very thick, inner sep=1em, minimum size=3em, text centered},
    myarrow/.style={->, >=latex', shorten >=1pt, thick},
    mylabel/.style={text width=7em, text centered} 
} 

\begin{document}

\shorthandoff{>}\shorthandoff{<}
 
 \graphicspath{{./}{./fig/}}

 \input{./titlepage.tex}

  \tableofcontents

 \clearpage


 
%\section{Palabras Clave}

%Arquitectura heterogénea, Multi-aceleradores, Multi-núcleo, Caracterización, Calendarización, Computación aproximada, Calidad.
\section{Palabras Clave}
Computación aproximada, arquitectura heterogénea, caracterización, aceleradores 
aproximados.


\section{Introducción}

Los sistemas de Tecnologías de Información (TI) buscan dar una mejor calidad de
vida a las personas. En esta tarea, estos sistemas han tenido que enfrentar
ciertos problemas, entre lellos el costo en área, potencia y tiempo de ejecución, los cuales 
restringen el rendimiento de un chip. Idealmente, una aplicación debe ajustarse a las 
necesidades reales del usuario y, en general, del área de aplicación, de forma que se dé un 
uso óptimo de los recursos. Actualmente, el diseño de procesadores no solo se enfoca en
contar con más desempeño si no en tener un manejo de recursos apropiado. No
obstante, algunos desafíos en este campo están dados por limitaciones físicas,
por ejemplo:

\begin{compactitem}
 \item las características eléctricas de los transistores CMOS, las cuales
 restringen el consumo de energía en sistemas embebidos y lo cual es un aspecto
 que deben considerar los diseñadores de componentes para propósito
 específico en procesadores;

 \item la pared de memoria, que corresponde a la diferencia entre el crecimiento
 de la capacidad de procesamiento contra la velocidad de obtención de datos
 desde la memoria;

 \item y la pared de utilización, la cual limita el uso máximo de hardware
 simultáneamente debido a las capacidades de disipación de calor de un sistema.
\end{compactitem}

Para poder enfrentar los problemas mencionados anteriormente, una área de
investigación actual corresponde a \emph{computación aproximada}, un
paradigma de diseño que propone una reducción en la precisión o exactitud de
la computación para obtener oportunidades de mejora en cuanto al consumo de
área, potencia y tiempo de ejecución. Para aplicar dicho paradigma es necesario
identificar aplicaciones tolerantes a errores y determinar, más específicamente,
cuáles secciones o funciones dentro de estas pueden ser sustituidas por
versiones aproximadas, de forma que se pueda generar un balance entre la calidad
de la salida y el consumo general de recursos.


Este documento busca explicar los detalles relacionados a la propuesta de un 
anteproyecto para el diseño asistido de aplicaciones aproximadas en sistemas 
computacionales personalizables, considerando una plataforma con multiples aceleradores 
de hardware disponibles. Con la realización del proyecto se espera constribuir a la 
investigación en el campo de la computación aproximada, especialmente en el Instituto 
Tecnológico de Karlsruhe en Alemania, así como en el de área de ingeniería en 
computadores en general.

En la siguiente sección se presenta el contexto y los antecedentes del proyecto, que 
incluye una descripción de la institución donde se realizará el trabajo final de graduación y 
el área de negocio específica de este. Seguidamente, se realiza la justificación del 
problema, la especificación  de los objetivos, la mención de los beneficios y beneficiarios 
con los resultados del proyecto, los supuestos y limitaciones sobre los que parte el 
proyecto y un análisis de riesgos del mismo. Finalmente, se detalla la metodología que se 
seguirá en el proyecto, la cual incluye la tipificación del trabajo, descripción de las tareas 
que se realizarán, las herramientas que se utilizarán, los entregables que se fijan para 
cumplir con los objetivos propuestos, las estrategias de verificación y validación que se 
seguirán y, por último, el cronograma de trabajo propuesto. 


\section{Contexto y Antecedentes}

\subsection{Descripción de la Institución}

El Instituto Tecnológico de Karlsruhe (KIT) surge en 2009 a partir de la fusión
de la Universidad de Karlsruhe, fundada en 1825 como Universidad Fridericiana, y
el Centro de Investigación de Karlsruhe. Se ubica en Karlsruhe, Baden-Wüttemberg, al 
suroeste de Alemania. 

El KIT es una de las universidades técnicas más prestigiosas de Alemania, la cual
se especializa en ciencias de la ingeniería. Según \cite{kitData} para el 2017 contó con 
25.495 estudiantes y 9.297 empleados. De acuerdo con \cite{kitOrganization} el KIT está 
divido en cinco divisiones:

\begin{itemize}
 \item División I: Biología, Química e Ingeniería de Procesos.
 
 \item División II: Informática, Economía y Sociedad.
 
 \item División III: Ingeniería Mecánica y Eléctrica.
 
 \item División IV: Ambiente Natural y Construido. 
 
 \item División V: Física y Matemática.
\end{itemize}


Las divisiones trabajan en aspectos de investigación, enseñanza e innovación. Los 
programas de investigación se organizan en programas  Helmholtz, donde se le da apoyo 
a las investigaciones multidisciplinarias. Los departamentos en el KIT son los responsables 
de la educación universitaria. La Figura \ref{fig:org} resume la organización que 
posee el KIT en el campo de ciencia.


\begin{figure}[t!]
\begin{center}
 \includegraphics[scale=0.31]{organization_KIT}
 \caption{Organización científica en el KIT (Tomado de \cite{kitOrganization}).}
 \label{fig:org}
 \end{center}
\end{figure}

El Instituto de Ingeniería en Computadores del KIT incluye grupos de trabajo
que abarcan los diferentes niveles de abstracción de sistemas computacionales.
En el \emph{Chair for Embedded Systems} (CES) se investigan diversos aspectos
relacionados con el diseño de sistemas embebidos, desde la confiabilidad de
circuitos hasta el manejo de potencia en sistemas multinúcleos.

El presente proyecto será desarrollado en el CES bajo la dirección del M.Sc. Jorge 
Castro-Godínez, ingeniero en electrónica, investigador y estudiante de doctorado, quien 
es egresado del Tecnológico de Costa Rica y posee más de tres años como investigador 
en el Instituto Tecnológico de Karlsruhe. 

\subsection{Área de Conocimiento}


El área de conocimiento principal del proyecto es computación aproximada (explicada 
brevemente en la sección de Contexto del Problema), la cual incluye aspectos tanto de 
software como de hardware, dado que involucra aspectos tanto de modificación del ISA 
como creación de ASIPs y aceleradores para la computación de ciertos algoritmos. Las 
áreas de conocimiento de ingeniería que se tratan son: conocimiento sobre aspectos de 
arquitectura y micro-arquitectura de procesadores (por lo mencionado anteriormente), 
desarrollo de compiladores, dado que se modificará el \emph{frontend} de un compilador 
(clang), finalmente, análisis de posibles aproximaciones en algoritmos en código escritos 
en el lenguaje de programación C, donde se espera agregar identificadores a las funciones 
que se busquen aproximar, para posteriormente ser procesadas de manera especial en la 
representación intermedia del código que se genere.


\section{Descripción de la Propuesta}

\subsection{Justificación y Definición del Problema}

\subsubsection{Contexto del Problema}

En la actualidad, dada la gran cantidad de aplicaciones complejas (por ejemplo
sistemas GPS, reconocimiento de voz, etc.), la computación aproximada ayuda a
mantener una salida aceptable mientras se logra que ciertas métricas como tiempo
de ejecución o eficiencia energética se mejoren. En general, la computación 
aproximada provee la libertad de escoger entre un cierto nivel de error o
degradación de la calidad en la salida final de una aplicación (por ejemplo
ruido en la señal de la salida) para mejorar el consumo de energía, el área o el
tiempo de ejecución; esto sirve como herramienta a un investigador para que ajuste
una aplicación dada a las necesidades reales y específicas de esta. En la Figura
\ref{fig:ap} se muestra un esquema que puede ser aplicado a sistemas tolerantes
a errores para incluir en estos la computación aproximada \cite{xu2018approximate}.


\begin{figure}[t!]
\begin{center}
 \includegraphics[scale=0.3]{APframework}
 \caption{Un marco de trabajo para el uso de computación aproximada (Tomado de
 \cite{xu2018approximate}).}
 \label{fig:ap}
 \end{center}
\end{figure}


Los elementos clave de la Figura \ref{fig:ap} son \emph{kernels} aproximados,
los cuales representan la implementación (técnicas) de las funciones
aproximadas, estas puede ser realizadas a nivel de hardware o de software; la
identificación de la secciones tolerantes a errores y sus características
particulares (análisis de impacto); y el manejo de la calidad, el cual implica
una evaluación continua para determinar si la aplicación logra los
requerimientos deseados.

Como se mencionó, la computación aproximada puede ser implementada tanto a nivel
de software como de hardware. En software una implementación típica es a través
de \emph{Loop Perforation}, en la cual ciertos ciclos (usualmente con un patrón
dado, como por ejemplo las pares) no son computados, lo cual, por ejemplo en una
aplicación de cálculo numérico, reduciría la precisión del valor final
calculado. A nivel de hardware, se pueden utilizan módulos especializados, por
ejemplo aceleradores para programas aproximados utilizando redes neuronales.

\marginnote{Pare que harías lo que Juan Carlos hizo, la parte del algoritmo.}[0.1cm]
El graduado de la carrera Ingeniería en Computadores Juan Carlos Cruz, realizó
un trabajo sobre la computación aproximada, donde él se dio a la tarea de
caracterizar aplicaciones tolerantes a errores. Parte del actual proyecto busca partir de los 
resultados generados por Cruz, de forma que se pueda utilizar el conocimiento generado
sobre secciones ya aproximadas, para poder desarrollar el algoritmo que seleccionará cuál 
de todas ellas es la mejor según las especificaciones de un usuario. 


\subsubsection{Especificación del Problema}

Al contar con una aplicación que presenta una estructura en \emph{pipeline}, es decir, que 
posee una serie de etapas donde cada etapa recibe su entrada de una etapa anterior y 
produce una salida para la etapa siguiente, y donde una o más etapas pueden ser 
aproximables con más de una versión aproximable (una versión se puede concentrar en 
mejorar el consumo de potencia, mientras que otra el tiempo de ejecución, por ejemplo) 
resulta complejo determinar qué combinación de versiones aproximadas utilizar de forma 
que no se sobrepase el error máximo permitido y a la vez se reduzca, de manera óptima, el 
uso de ciertos recursos. Dicho proceso podría tomar una cantidad considerable de tiempo 
si se decide probar todas las posibles combinaciones posibles de versiones aproximadas, 
por lo que es importante utilizar un esquema de trabajo diferente.

Una aplicación puede tener un comportamiento aproximado si alguna de sus etapas se 
puede aproximar, ya sea toda una sección o únicamente una instrucción (dentro de una 
sección). La Figura \ref{fig:problem} muestra como ejemplo una aplicación genérica donde 
ambas situaciones pueden ocurrir.


\begin{figure}[t!]
\centering
\begin{tikzpicture}[node distance=1cm, auto]  
\tikzset{
    mynode/.style={rectangle,rounded corners,draw=black, very thick, minimum
    size=3em, text centered},
    myarrow/.style={->, >=latex', shorten >=1pt, thick},
    mylabel/.style={text width=7em, text centered} 
}  
\node[mynode] (manufacturer) {Aplicación};  
\node[mynode, below left =3cm of manufacturer] (section1) {Sección 1}; 
\node[mynode, below=2.16cm of manufacturer] (section2) {Sección 2};
\node[mynode, below right=3cm of manufacturer] (section3) {Sección 3};

\node[mynode, below=1cm of section1, dashed] (comment1) {\makecell{Toda esta
sección \\ puede ser aproximada}};

\node[mynode, below left=3cm of section3] (instru1) {Instrucción 1};
\node[mynode, below =2.16cm of section3] (instru2) {Instrucción 2};
\node[mynode, below right=3cm of section3] (instru3) {Instrucción 3};

\node[mynode, below=1cm of instru2, dashed] (comment2) {\makecell{Esta
instrucción específica\\ puede ser reemplazada por \\ una versión aproximada}};


\draw[myarrow] (manufacturer.south)  -- ++(0,-1) -|  (section1.north);
\draw[myarrow] (manufacturer.south)   -|  (section2.north);
\draw[myarrow] (manufacturer.south)  -- ++(0,-1) -|  (section3.north); 

\draw[->, >=latex', shorten >=1pt, thick, dashed]  (comment1.north) -|  (section1.south); 

\draw[myarrow] (section3.south)  -- ++(0,-1) -|  (instru1.north);
\draw[myarrow] (section3.south)   -|  (instru2.north);
\draw[myarrow] (section3.south)  -- ++(0,-1) -|  (instru3.north); 
 
 \draw[->, >=latex', shorten >=1pt, thick, dashed]  (comment2.north) -|  (instru2.south); 
 
\end{tikzpicture} 
\medskip
\caption{Una posible aplicación aproximada genérica analizada en este proyecto.} 
\label{fig:problem}
\end{figure}

Como se muestra en la Figura \ref{fig:problem}, esta aplicación posee tres
secciones, de las cuales la primera (por ejemplo, una etapa de preprocesamiento)
puede ser completamente aproximada, la segunda no puede ser aproximada del todo 
(por ejemplo, una sección crítica de la aplicación) y, finalmente, la tercera
tiene tres instrucciones específicas, de las cuales únicamente la segunda posee
una versión aproximada.

En el caso hipotético de la Figura \ref{fig:problem} donde se tenga más de una
versión aproximada para la sección 1 y para la instrucción 2 de la sección 3,
es dificulta determinar qué combinación de versiones aproximadas produce la mejor 
aplicación aproximada final, debido a que, por ejemplo, un cambio en la sección 1 puede 
impactar severamente las secciones 2 y 3, pues dicha complejidad aumenta con la 
cantidad de versiones aproximadas; inclusive, puede que la versión aproximada de la 
instrucción 2 determine qué tipo de versiones aproximadas son las más convenientes 
(según las especificaciones del usuario) en la sección 1 para no impactar en gran medida 
la calidad de la aplicación. 

Negocio \marginnote{¿Negocio?}[0.1cm]

\emph{NOTA: Hasta aquí es la motivación para lo que Juan Carlos hizo, pero no para lo 
que vos vas a hacer. Así que falta incluir lo que será tu contribución}

\subsubsection{Justificación de la Necesidad}

Debido a la creciente necesidad por un consumo eficiente de recursos, ya sea energía,
área o tiempo de ejecución, la computación aproximada, como alternativa de solución 
a este problema, se considera considerablemente importante. El diseño de un marco
de trabajo para la realización de aplicaciones personalizadas mediante el uso de 
computación aproximada puede traer nuevos conocimientos a esta área de investigación y 
potenciar la creación de más aplicaciones, especializadas según los requerimientos
específicos de los usuarios. 

Con este proyecto, el conocimiento generado en Alemania se puede traer para obtener 
grandes beneficios en Costa Rica, de tal forma que se incentive la investigación, e 
inclusive una posible inversión en esta área. Actualmente no existe una herramienta 
académica que realice lo que se plantea en esta propuesta, por lo que se espera que el 
proyecto incentive muchos otros proyectos en el área de generación de procesadores
con instrucciones especializadas. 


\subsection{Enfoque de la solución}

\emph{Se debe cambiar la figura, y ajustar la descripción del enfoque de la solución de 
acuerdo al nuevo diagrama. Ver diagrama propuesto}

Se busca desarrollar una herramienta de software que pueda escoger entre
diferentes versiones para una aplicación aproximada (cada versión dada por una
combinación diferente de versiones específicas para cada sección aproximable),
según el criterio de usuario que especifique cuáles recursos son críticos en
la aplicación y cuál es la cantidad máxima de error permitido. La Figura 
\ref{fig:sol} muestra una abstracción de la implementación de esta herramienta.

\begin{figure}[t!]
\centering
\resizebox{\textwidth}{!}{\begin{tikzpicture}[node distance=1cm, auto]  
\tikzset{
    mynode/.style={rectangle,rounded corners,draw=black, very thick, minimum
    size=3em, text centered},
    myarrow/.style={->, >=latex', shorten >=1pt, thick},
    mylabel/.style={text width=7em, text centered} 
}  
\node[mynode] (codfuente) {\makecell{Código fuente con anotaciones,\\error
permitido y prioridad de recursos}};
\node[mynode, below =2cm of codfuente] (extraccion) {\makecell{Extracción de
información/\\transformación de código}}; 


\draw[myarrow] (codfuente.south)  -|  (extraccion.north);

\draw (6,1) ellipse (1.25 and 0.2);
\draw (4.75,1) -- (4.75,-0.5);
\draw (4.75,-0.5) arc (180:360:1.25 and 0.2);
\draw (7.25,-0.5) -- (7.25,1);  

\node[] at (6,0) (bd) {\makecell{Versiones\\aproximadas}}; 

\node[mynode, below = 1.98cm of bd] (deterVersiones) {\makecell{Determinación
de\\ versiones óptimas}};

\draw[myarrow] (extraccion.east)  ->  (deterVersiones.west);
\draw[myarrow] (6,-0.7)  -|  (deterVersiones.north);

\node[mynode, right = 1cm of deterVersiones] (confHardware) {
\makecell{Sustitución de código/\\uso de instrucciones aproximadas}};

\draw[myarrow] (deterVersiones.east)  ->  (confHardware.west);

\node[mynode, right = 1.5cm of confHardware] (final) {Aplicación aproximada
final};

\draw[myarrow] (confHardware.east)  ->  (final.west);

\draw[dashed] (-3,-5) -- (-3,-1.5) -- (16,-1.5) -- (16,-5) -- (-3,-5) ;

\end{tikzpicture}}
\medskip
\caption{Esquema general de la solución propuesta.} 
\label{fig:sol}
\end{figure}


Como se muestra en la Figura \ref{fig:sol}, se espera recibir un código fuente
de una aplicación aproximable, donde previamente el usuario ha indicado, a
través de pragmas propios, qué funciones del código son tolerantes a errores; este
es transformado a una representación intermedia. El algoritmo que se pretende
desarrollar busca poder escoger cuáles versiones aproximadas de
las posibles que existen se ajustan para cumplir a cabalidad con el error
permitido y, de la mejor manera, con la priorización de recursos. Una vez
identificadas las versiones que serán utilizadas, se procederá a sustituir el
código específico que cuente con el soporte para las instrucciones aproximadas
correspondientes, para finalmente entregar una aplicación final aproximada. 

\subsection{Especificación de Objetivos}

\subsubsection{Objetivo General}
Desarrollar una herramienta que, a partir de información sobre diferentes
versiones de secciones aproximadas de una aplicación tolerante a errores, pueda
determinar cuál combinación de versiones genera un mejor resultado en términos
de ahorro de recursos y el nivel de error máximo que un usuario estableció como
permitido.

\emph{Este es el objetivo del trabajo de Juan Carlos. Hay que adaptarlo a los objetivos 
que hablamos en la última reunión.}


\subsubsection{Objetivos Específicos}

\begin{enumerate}
 \item Modificar el \emph{frontend} (clang) de un compilador de forma que se reconozca  
 anotaciones propias que se agreguen en el código para establecer qué funciones son  
 aproximables.

 \item Generar una representación del código de entrada que sea manipulable a
 partir de las anotaciones dadas por un usuario.
 
 \item Generar una nueva versión de código ejecutable donde se las anotaciones
 sean sustituidas por los aceleradores o versiones aproximadas correspondientes.
 
 \item Verificar que la aplicación final aproximada cumpla con el funcionamiento
 de la aplicación original y las restricciones dadas por el usuario y por el la
 aplicación.
\end{enumerate}

\emph{El objetivo 2 no es claro. El objetivo 4 implica que tendriamos que correr la nueva 
version en la plataforma final y además es confuso en su redacción. Para fines del TEC 
habíamos dicho que quedaría fuera, pero podemos incluirlo. En general tenemos que 
revisar la redacción de estos objetivos.}




\subsection{Beneficios y Beneficiarios con la Propuesta}

\begin{enumerate}
 \item Daniel Esteban Moya Sánchez: Se podrán fortalecer los conocimientos de 
 arquitectura en computadores, compiladores, y aproximaciones a nivel de hardware y 
 software, todo esto en un ambiente internacional, el cual aumentará el panorama cultural 
 que se tiene, con los  beneficios personales que esto conlleva.  Se espera cunplir con los 
 requerimientos del curso CE5600 Trabajo Final de Graduación, para así completar el plan 
 de estudios 2100 de la carrera de Ingeniería en Computadores y poder graduarse para el 
 año 2019. 
 
 \item Jorge Alberto Castro Godínez: Profesor tutor en el KIT, Alemania. Es investigador y 
 estudiante de doctorado, a cargo de varios proyectos en el CES. Dentro de los beneficios 
 está el conocimiento que se genere dado a el intercambio de ideas y resultados del 
 proyecto, que ampliarán las habilidades técnicas tanto a nivel de hardware como de 
 software. 
 
 \item Chair for Embedded Systems (CES): Corresponde al lugar específico en el KIT donde 
 se estará llevando a cabo el proyecto. El proyecto propuesto podrá formar parte de la 
 investigación en el CES, lo cual beneficia parte de las áreas de investigación que trata. Se 
 espera que los resultados del proyecto incentiven nuevos proyectos y aumenten así el 
 conocimiento en el área de computación aproximada.
 
 
 \item Instituto Tecnológico de Costa Rica: Como parte de los principios de investigación y 
 extensión, para el TEC es sumamente importante la presencia de estudiantes en el 
 exterior. Los conocimientos que se generan a partir del proyecto propuesto podrán mejor 
 la investigación en el TEC, e incentivar el área de computación aproximada. 
\end{enumerate}


\subsection{Supuestos y Limitaciones}

\begin{enumerate}
\item Limitación de tiempo: El proyecto se debe completar en un periodo menor a 5 meses, 
específicamente del 1 de Julio al 20 de Noviembre del 2018, dado que se necesita regresar 
al país para realizar la defensa presencial del proyecto en el TEC, además de realizar los 
trámites correspondientes para la graduación del 2019. 

\item Disponibilidad de recursos: El proyecto se realizará utilizando herramientas de 
software libres. Para investigar se utilizará internet y el material disponible en el CES. 
Cualquier material físico del proyecto (como placa FPGA de desarrollo) será provisto por el 
CES.

\item Disponibilidad de versiones de aplicaciones aproximadas: El proyecto parte de la 
existencia de diferentes versiones aproximadas de funciones en aplicaciones tolerantes a 
errores, que se utilizarán como base para el trabajo de personalización de aplicaciones, es 
decir, selección de versiones diferentes aproximadas.
\end{enumerate}


\subsection{Análisis de Riesgos}

En la Tabla \ref{tab:risk} se resumen los riesgos que se consideran para el proyecto.

\begin{table}[h!]
\begin{center}
\caption{Posibles riesgos del proyecto.} 
\resizebox{\textwidth}{!}{\begin{tabular}{|c|c|c|c|c|} 
 \hline
ID	&Descripción	&\makecell{Probabilidad\\ de ocurrencia}	&\makecell{Impacto\\ (horas)}	&Plan de Acción \\ \hline
1	&\makecell{Falta de disponibilidad de asesores para el\\ proyecto}	&0.2	&16	
&Aceptar \\ \hline
2	&\makecell{Carencia de materiales necesarios para el\\ proyecto}	&0.2	&8	&Evitar \\ \hline
3	&\makecell{Errores a la hora de modificar clang}	&0.3	&12	&Mitigar \\ \hline
\end{tabular}}
\label{tab:risk}
\end{center}
\end{table}

A continuación se explica cada riesgo detalladamente:

\begin{enumerate}
 \item Falta de disponibilidad de asesores para el proyecto: Corresponde a momentos en que, ya sea el supervisor Jorge Castro o el director de tesis
 no puedan atender alguna duda o no simplemente no se encuentren disponibles en una semana determinada, lo cual atrase la revisión del trabajo.
 
 \item Carencia de materiales necesarias para el proyecto: El atraso de la entrega o no la presencia de alguno de los materiales (información o programas de software principalmente) que se necesitan
 para realizar el proyecto, siendo el más importante las versiones aproximadas de las funciones que se analizarán. 
 
 \item Errores a la hora de modificar clang: Problemas de dependencias o aceptación de las 
 modificaciones pensadas para el \emph{frontend} clang. 
 
\end{enumerate}

Los planes de acción se detallan a continuación:

\begin{enumerate}
 \item Aceptar: Asumir la responsabildidad correspondiente y continuar trabajando, con más cuidado inclusive y realizando un auto-análisis.
 
 \item Evitar: Definir apenas comience el proyecto los materiales y sus fuentes con las que se contarán, de tal modo que se pueda contar con ellos (o al menos con una copia digitial)
 para evitar contratiempos de adquisición cuando se necesiten en el proyecto.
 
 \item Mitigar: Se realizará una investigación previa del \emph{frontend} clang y se 
 realizarán  cambios iterativos, de tal forma que poco a poco se verifique las nuevas 
 funcionalidades que se agreguen a clang. 
 
\end{enumerate}



\section{Propuesta Metodológica}

\subsection{Tipificación del Trabajo}

El proyecto se clasifica como un trabajo de investigación aplicada, con alto porcentaje de 
experimentación. Esto se debe a que no existe ninguna herramienta que realice lo que se 
plantea y se busca incursionar en un campo relativamente nuevo (considerando la 
tecnología del país y la educación recibida hasta el momento), donde se espera que los 
resultados obtenidos inspiren nuevos proyectos en el área. 

\subsection{Descripción del Proceso}

La Figura \ref{fig:proceso} resume el proceso que se realizará durante el proyecto.
Como se puede observar, el proyecto iniciará 
con una etapa de investigación sobre trabajos realizados
por varios autores en el área de computación aproximada, relacionados con la
caracterización de sistemas o aplicaciones en las cuales una o varias secciones
son aproximables. Se investigará sobre maneras de generar un compilador para un
cierto lenguaje y que permita el reconocimiento de pragmas o anotaciones en el código.

\emph{La parte de investigación sobre otros trabajos relacionados será mínima, también la 
parte de generar un compilador para un cierto lenguaje, eso es algo muy extenso. Lo que 
nos interesa es poder modificar clang para que pueda manejar ciertos pragmas y los 
pueda poner como metadata en la representación intermedia. Luego tu herramienta 
determinará que hacer con la información que obtenga de esos pragmas.}


\begin{figure}[t!]
\centering
\begin{tikzpicture}[node distance=1cm, auto]  
\tikzset{
    mynode/.style={rectangle,rounded corners,draw=black, very thick, minimum
    size=3em, text centered},
    myarrow/.style={->, >=latex', shorten >=1pt, thick},
    mylabel/.style={text width=7em, text centered} 
}  
\node[mynode] (investigacion) {Investigación sobre antecedentes y trabajos previos};

\node[mynode, below=1cm of investigacion] (compilador) {Modificación de compilador con pragmas propios};

\draw[myarrow] (investigacion.south)   -|  (compilador.north);

\node[mynode, below=1cm of compilador] (algoritmo) {\makecell{Desarrollo de algoritmo para evaluar impacto de\\ versiones aproximadas}};
 
 \draw[myarrow] (compilador.south)   -|  (algoritmo.north);
 
 
 \node[mynode, below=1cm of algoritmo] (verificacion) {Verificación de versones aproximadas finales};
 
  
   \draw[<->, >=latex', shorten >=1pt, thick]  (algoritmo.south) -- (verificacion.north); 
  
 
  
  \node[mynode, right=1.8cm of investigacion, dashed] (ini) {Documentación};

  \node[mynode, right=2cm of verificacion] (fin) {Documentación final}; 
  
 
 \draw[->, >=latex', shorten >=1pt, thick, dashed]  (ini.south) -|  (fin.north); 

\end{tikzpicture} 
\medskip
\caption{Proceso a realizar en este proyecto.} 
\label{fig:proceso}
\end{figure}



Seguidamente, se implementará un algoritmo que, a partir de una información dada
(gracias a una base de datos) determine qué combinación de funciones aproximadas
se deben colocar en un sistema en pipeline de tal forma que el resultado al
final de todas las etapas se mantenga en un nivel de error aceptable. Para esto
se tomará información de una base de datos del KIT sobre secciones aproximadas
independientes, para posteriormente evaluar el impacto final de cada una de
ellas en una aplicación completa.

\emph{Debe quedar claro que el algoritmo "ya va a estar disponible" y que tu labor es 
"portearlo" a esta herramienta.}

\emph{Hace falta mencionar, previo a usar el algoritmo, que de la representación 
intermedia del código se debe extraer/generar un arbol de llamadas (o por el estilo) que 
nos permita representar los bloques/funciones del programa, sobre los cuales el algoritmo 
va a trabajar. Esto te lo puedo explicar con más detalle si aún no te queda claro.}

Finalmente, se debe realizar la verificación de la aplicación aproximada final,
de forma que se garantice un cumplimiento en el nivel de error y una optimización
apropiada de los recursos. Para esto se realizarán simulaciones y pruebas
unitarias en plataformas como ModelSim. Si por alguna razón se detectaran
fallas, se revisará el algoritmo desarrollado con el fin de poder
corregirlo. 

La documentación del proyecto se trabajará a lo largo de todo el proceso de
desarrollo, de forma que al final se genere un artículo científico y demás
documentos propios de un trabajo final de graduación.



\subsection{Herramientas}

\begin{enumerate}
 \item Lenguaje de programación: El software desarrollado utilizará C/C++ como lenguaje de programación.
 
 \item Sistema operativo: Se utilizará Ubuntu 17.10.
 
 \item Compiladores: Se utilizará la versión 7.2.0 para GCC/G++ 
 \emph{clang puede no funcionar con versiones tan nuevas de gcc/g++, esto es, puede 
 generar errores cuando se vaya a compilar el frontend}
 
 \item Editor de texto: Para la documentación se utilizará LaTeX, con el ambiente de desarrollo Kile y compartido
 a través de Git. Para programar, se utilizará principalmente el editor en terminal Vim.
\end{enumerate}



\subsection{Descripción de Entregables}

La tabla \ref{tab:entrega} presenta la asociación entre entregables y objetivos del proyectos.


\begin{table}[h!]
\begin{center}
\caption{Entregables del proyecto}
\resizebox{\textwidth}{!}{\begin{tabular}{|c|c|} 
 \hline
Objetivo	&Entregable \\ \hline

\makecell{Modificar el compilador de front-end Clang de forma que se\\ reconozcan las anotaciones propias
que se agreguen en el \\código para establecer qué funciones son aproximables.}	&Compilador Clang modificado con pragmas propios \\ \hline
 \makecell{Generar una representación del código de entrada que sea\\ manipulable a partir de las anotaciones
 dadas por un usuario.}	&\makecell{Código en representación de árbol de llamadas\\ o \emph{function code graph} u otro tipo de \\representación según se determine.} \\ \hline
 \makecell{Generar una nueva versión de código ejecutable donde se\\ las anotaciones sean sustituidas por
 los aceleradores o \\versiones aproximadas correspondientes.}	&\makecell{Código generado con anotaciones (pragmas) sustituidas} \\ \hline
 \makecell{Validar que la aplicación final aproximada cumpla con el \\ funcionamiento
 de la aplicación original y las restricciones\\ dadas por el usuario y por el la
 aplicación}	&Aplicación aproximada final y documentación \\ \hline

\end{tabular}}
\label{tab:entrega}
\end{center}
\end{table}


\subsection{Estrategias de Verificación y Validación}

Dado que se trata de un proyecto de investigación, cada uno de los entregables mencionados anteriormente tendrá un conjunto de pruebas
asociado, las cuales corresponden a:

\begin{itemize}
 \item Pruebas para compilador Clang: se empezará por un código sin ningún version modificada y se irán realizando pruebas unitarias para cada
 pragma nuevo que se agregue.
 
 \item Pruebas para el código en representación intermedia: se revisará manualmente que el código en esta interpretación sea correcto. 
 
 \item Pruebas para el código final generado (con pragmas sustituidos): el supervisor probará el código y determinará si cumple 
 con los diferentes tipos de posibles requerimientos de un usuario.
\end{itemize}


Todas las pruebas mencionadas anteriormente serán llevadas a cabo mediante la supervisión de Jorge Castro y la contraparte en el TEC que se asigne. 



\subsection{Cronograma de Trabajo Propuesto}


Considerando los 4 meses (16 semanas) del semestre, el cronograma de trabajo para el proyecto propuesto se muestra en la tabla \ref{tab:schd}. 




\begin{table}[h!]
\begin{center}
\caption{Cronograma para el proyecto propuesto}
\resizebox{\textwidth}{!}{\begin{tabular}{ | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c |} 
 \hline
   & \multicolumn{16}{|c|}{Semana} \\
 \hline
 Actividad & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 \\ \hline
 \makecell{Modificación de clang}
 & \cellcolor[HTML]{5B9BD5}  & \cellcolor[HTML]{5B9BD5} & \cellcolor[HTML]{5B9BD5}  & \cellcolor[HTML]{5B9BD5}  &  &  &  &  &  &  &  &  &  &  &  &  \\ \hline
 \makecell{Generación de representación \\intermedia}
 &   &  &   &   &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &  &  &  &  &  &  &  &  \\ \hline
  \makecell{Generación de código con\\ pragmas sustituidas}
 &   &  &   &   &  &  &  & &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &  &  &  &  \\ \hline
 \makecell{Validación de aplicación final}
 &  &   &  &  &  &  &  &  &  &  &\cellcolor[HTML]{5B9BD5} &\cellcolor[HTML]{5B9BD5} &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &  &  \\ \hline
 \makecell{Documentación final} &  &   &  &  &  &  &  &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &\cellcolor[HTML]{5B9BD5}  &
     \cellcolor[HTML]{5B9BD5} & \cellcolor[HTML]{5B9BD5} & \cellcolor[HTML]{5B9BD5} & \cellcolor[HTML]{5B9BD5} &  \\ \hline
  \makecell{Elaboración de presentación \\para la defensa del Trabajo \\Final de Graduación}
 &  &   &  &  &  &  &  &  &  &  &  &  &  &  & \cellcolor[HTML]{5B9BD5} & \cellcolor[HTML]{5B9BD5} \\ \hline
 \end{tabular}}
\label{tab:schd}
\end{center}
\end{table}



% Referencias del Background y el Related Work
\bibliographystyle{sty/plainurl}
\bibliography{references}

\newpage
\centerline{\large\bf Ingeniería en Computadores}
\par\vspace{2mm}
\centerline{\large\bf Ficha de contactos del proyecto}

\textbf{Datos del estudiante}

\begin{tabu} to \textwidth {| X[l] | X[l] |}	
 \hline
 Nombre	& Daniel Esteban Moya Sánchez \bigskip \\ \hline
 Correo electrónico	&danielmscr1994@gmail.com \bigskip \\ \hline
 Teléfonos	&(+506) 8325 9730 \bigskip \\ \hline
\end{tabu}

\par\vspace{8mm}


\textbf{Datos del proyecto}

\begin{tabu} to \textwidth {| X[l] | X[l] |}	
 \hline
 Nombre	&Diseño asistido de aplicaciones aproximadas para sistemas computacionales personalizables \bigskip \\ \hline
 Breve descripción	&Se desarrollará una herramienta que, a partir de información sobre diferentes
versiones de secciones aproximadas de una aplicación tolerante a errores, pueda
determinar cuál combinación de versiones genera un mejor resultado en términos
de ahorro de recursos y el nivel de error máximo que un usuario estableció como
permitido. \bigskip \\ \hline
 Fecha de inicio	&Lunes 2 de Julio del 2018 \bigskip \\ \hline
\end{tabu}


\par\vspace{8mm}


\textbf{Datos de la empresa u organización}

\begin{tabu} to \textwidth {| X[l] | X[l] |}	
 \hline
 Nombre	&Chair for Embedded Systems (CES), Instituto Tecnológico de Karlsruhe (KIT), Alemania \bigskip \\ \hline
 
 Nombre contacto	&Jorge Alberto Castro Godínez, M.Sc.\bigskip \\ \hline
 Correo electrónico	&jocastro@itcr.ac.cr \bigskip \\ \hline
 Teléfonos	&+49 721 608 48780 \bigskip \\ \hline
\end{tabu}

\end{document}

