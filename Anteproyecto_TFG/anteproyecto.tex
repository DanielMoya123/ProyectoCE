%% ---------------------------------------------------------------------------
%% proposal.tex
%%
%% Research Proposal, main document.
%%
%% ---------------------------------------------------------------------------
\documentclass[12pt,letterpaper]{article}
% \usepackage[english]{babel}     % supports english, but default is
 \usepackage[spanish]{babel}
% include this if you want to import graphics files with /includegraphics

\usepackage{longtable}
\usepackage{ifpdf}
\usepackage[table]{xcolor}

\usepackage{anysize}
\marginsize{2.5cm}{2.5cm}{1cm}{1cm}
\usepackage{textcomp}
\usepackage{url}
\bibliographystyle{unsrt}
\usepackage{graphics}
\usepackage{amssymb}
\usepackage{graphicx}
%\usepackage{slashbox}
\usepackage[latin1]{inputenc}
\usepackage{tikz}
\usetikzlibrary{arrows,positioning}
\usetikzlibrary{shapes.geometric}
% Color and strikethrough

% For compactenum
\usepackage{paralist}



\usepackage{color}
\usepackage{soul}

\usepackage{array}
\usepackage{makecell}

\usepackage{sectsty}
\allsectionsfont{\sffamily}

\definecolor{dblue}{RGB}{0,102,153}
\newcommand{\dB}[1]{\textcolor{dblue}{\textbf{#1}}}



\setlength{\parskip}{1em}

% Nombre del Estudiante
\newcommand{\scriptAuthor}{Daniel Moya Sánchez}
 
% Tí­tulo de la tesis
\newcommand{\scriptTitle}{Diseño asistido de aplicaciones aproximadas para
sistemas computacionales personalizables}


% Keywords
\newcommand{\scriptKeywords}{key, words, ...}

% Para el PDF (cambiar si se desea otras cosas a lo indicado arriba
\newcommand{\pdfAuthor}{\scriptAuthor}
\newcommand{\pdfTitle}{\scriptTitle} 
\newcommand{\pdfKeywords}{\scriptKeywords}


\tikzset{
    mynode/.style={rectangle,rounded corners,draw=black, top color=white, bottom color=yellow!50,very thick, inner sep=1em, minimum size=3em, text centered},
    myarrow/.style={->, >=latex', shorten >=1pt, thick},
    mylabel/.style={text width=7em, text centered} 
} 

\begin{document}

\shorthandoff{>}\shorthandoff{<}
 
 \graphicspath{{./}{./fig/}}

 \input{./titlepage.tex}

%  \tableofcontents

 \clearpage


 
%\section{Palabras Clave}

%Arquitectura heterogénea, Multi-aceleradores, Multi-núcleo, Caracterización, Calendarización, Computación aproximada, Calidad.


\section{Introducción}

Los sistemas de Tecnologías de Información (TI) buscan dar una mejor calidad de
vida a las personas. En esta tarea, estos sistemas han tenido que enfrentar
ciertos problemas entre los que se puede mencionar el costo en área, potencia y 
tiempo de ejecución, las cuales son variables que restringuen el rendimiento de
un chip. Idealmente, una aplicación debe ajustarse a las necesidades reales del
usuario y, en general, del área de aplicación, de forma que se dé un uso óptimo
de los recursos. Actualmente, el diseño de procesadores no solo se enfoca en
contar con más desempeño si no en tener un manejo de recursos apropiado. No
obstante, algunos desafíos en este campo están dados por limitaciones físicas,
por ejemplo:

\begin{compactitem}
 \item las características eléctricas de los transistores CMOS, las cuales
 restringen el consumo de energía en sistemas embebidos y lo cual es un aspecto
 que deben considerar los diseñadores de componentes para propósito
 específico en procesadores;

 \item la pared de memoria, que corresponde a la diferencia entre el crecimiento
 de la capacidad de procesamiento contra la velocidad de obtención de datos
 desde memoria;

 \item y la pared de utilización, la cual limita el uso máximo de hardware
 simultáneo debido a las capacidades de disipación de calor de un sistema.
\end{compactitem}

Para poder atacar los problemas mencionados anteriormente, una de las áreas de
investigación actuales corresponde a la \emph{computación aproximada}, un
paradigma de diseño que propone una reducción en la precisión o exactitud de
la computación para obtener oportunidades de mejora en cuanto al consumo de
área, potencia y tiempo de ejecución. Para aplicar dicho paradigma es necesario
identificar aplicaciones tolerantes a errores y determinar, más específicamente,
cuáles secciones o funciones dentro de estas pueden ser sustituidas por
versiones aproximadas, de forma que se pueda generar un balance entre la calidad
de la salida y el consumo general de recursos.


\section{Descripción del problema}

Al contar con una aplicación que presenta una estructura en \emph{pipeline}, es
decir, que posee una serie de etapas donde cada etapa recibe su entrada de una
etapa anterior y produce una salida para la etapa siguiente, y donde una o más
etapas pueden ser aproximables con más de una versión aproximable (una versión
se puede concentrar en mejorar el consumo de potencia, mientras que otra el
tiempo de ejecución, por ejemplo) resulta complejo determinar qué combinación de
versiones aproximadas utilizar de forma que no se sobrepase el error máximo
permitido y a la vez se reduzca, de manera óptima, el uso de ciertos recursos.
Dicho proceso podría tomar una cantidad considerable de tiempo si se decide
probar todas las posibles combinaciones posibles de versiones aproximadas, por
lo que es importante utilizar un esquema de trabajo diferente.

Una aplicación puede tener un comportamiento aproximado si alguna de sus etapas
se puede aproximar, ya sea toda una sección o únicamente una instrucción (dentro
de una sección). La Figura \ref{fig:problem} muestra como ejemplo 
una aplicación genérica
donde ambas situaciones pueden ocurrir.


\begin{figure}[h!]
\centering
\begin{tikzpicture}[node distance=1cm, auto]  
\tikzset{
    mynode/.style={rectangle,rounded corners,draw=black, very thick, minimum
    size=3em, text centered},
    myarrow/.style={->, >=latex', shorten >=1pt, thick},
    mylabel/.style={text width=7em, text centered} 
}  
\node[mynode] (manufacturer) {Aplicación};  
\node[mynode, below left =3cm of manufacturer] (section1) {Sección 1}; 
\node[mynode, below=2.16cm of manufacturer] (section2) {Sección 2};
\node[mynode, below right=3cm of manufacturer] (section3) {Sección 3};

\node[mynode, below=1cm of section1, dashed] (comment1) {\makecell{Toda esta
sección \\ puede ser aproximada}};

\node[mynode, below left=3cm of section3] (instru1) {Instrucción 1};
\node[mynode, below =2.16cm of section3] (instru2) {Instrucción 2};
\node[mynode, below right=3cm of section3] (instru3) {Instrucción 3};

\node[mynode, below=1cm of instru2, dashed] (comment2) {\makecell{Esta
instrucción específica\\ puede ser reemplazada por \\ una versión aproximada}};


\draw[myarrow] (manufacturer.south)  -- ++(0,-1) -|  (section1.north);
\draw[myarrow] (manufacturer.south)   -|  (section2.north);
\draw[myarrow] (manufacturer.south)  -- ++(0,-1) -|  (section3.north); 

\draw[->, >=latex', shorten >=1pt, thick, dashed]  (comment1.north) -|  (section1.south); 

\draw[myarrow] (section3.south)  -- ++(0,-1) -|  (instru1.north);
\draw[myarrow] (section3.south)   -|  (instru2.north);
\draw[myarrow] (section3.south)  -- ++(0,-1) -|  (instru3.north); 
 
 \draw[->, >=latex', shorten >=1pt, thick, dashed]  (comment2.north) -|  (instru2.south); 
 
\end{tikzpicture} 
\medskip
\caption{Una posible aplicación aproximada genérica analizada en este proyecto.} 
\label{fig:problem}
\end{figure}

Como se muestra en la Figura \ref{fig:problem}, esta aplicación posee tres
secciones, de las cuales la primera (por ejemplo, una etapa de preprocesamiento)
puede ser completamente aproximada, la segunda no puede ser aproximada del todo 
(por ejemplo, una sección crítica de la aplicación) y, finalmente, la tercera
tiene tres instrucciones específicas, de las cuales únicamente la segunda posee
una versión aproximada.

En el caso hipotético de la Figura \ref{fig:problem} donde se tenga más de una
versión aproximada para la sección 1 y para la instrucción 2 de la sección 3,
es complicado (dicha complejidad aumenta con la cantidad de versiones aproximadas)
determinar qué combinación de versiones aproximadas produce la mejor aplicación 
aproximada final, debido a que, por ejemplo,
un cambio en la sección 1 puede impactar
severamente las secciones 2 y 3; inclusive, puede que la versión 
aproximada de la instrucción 2 determine que tipo de versiones aproximadas son las 
más convenientes (según las especificaciones del usuario)
en la sección 1 para no impactar en gran medida la calidad
de la aplicación. 



\section{Enfoque de la solución}

Se busca desarrollar una herramienta de software que pueda escoger entre
diferentes versiones para una aplicación aproximada (cada versión dada por una
combinación diferente de versiones específicas para cada sección aproximable),
según el criterio de usuario que especifique cuáles recursos son críticos en
la aplicación y cuál es la cantidad máxima de error permitido. La Figura 
\ref{fig:sol} muestra una abstracción de la implementación de esta herramienta.

\begin{figure}[h!]
\centering
\resizebox{\textwidth}{!}{\begin{tikzpicture}[node distance=1cm, auto]  
\tikzset{
    mynode/.style={rectangle,rounded corners,draw=black, very thick, minimum
    size=3em, text centered},
    myarrow/.style={->, >=latex', shorten >=1pt, thick},
    mylabel/.style={text width=7em, text centered} 
}  
\node[mynode] (codfuente) {\makecell{Código fuente con anotaciones,\\error
permitido y prioridad de recursos}};
\node[mynode, below =2cm of codfuente] (extraccion) {\makecell{Extracción de
información/\\transformación de código}}; 


\draw[myarrow] (codfuente.south)  -|  (extraccion.north);

\draw (6,1) ellipse (1.25 and 0.2);
\draw (4.75,1) -- (4.75,-0.5);
\draw (4.75,-0.5) arc (180:360:1.25 and 0.2);
\draw (7.25,-0.5) -- (7.25,1);  

\node[] at (6,0) (bd) {\makecell{Versiones\\aproximadas}}; 

\node[mynode, below = 1.98cm of bd] (deterVersiones) {\makecell{Determinación
de\\ versiones óptimas}};

\draw[myarrow] (extraccion.east)  ->  (deterVersiones.west);
\draw[myarrow] (6,-0.7)  -|  (deterVersiones.north);

\node[mynode, right = 1cm of deterVersiones] (confHardware) {
\makecell{Configuración del hardware/\\uso de instrucciones aproximadas}};

\draw[myarrow] (deterVersiones.east)  ->  (confHardware.west);

\node[mynode, right = 1.5cm of confHardware] (final) {Aplicación aproximada
final};

\draw[myarrow] (confHardware.east)  ->  (final.west);

\draw[dashed] (-3,-5) -- (-3,-1.5) -- (16,-1.5) -- (16,-5) -- (-3,-5) ;

\end{tikzpicture}}
\medskip
\caption{Esquema general de la solución propuesta.} 
\label{fig:sol}
\end{figure}


Como se muestra en la Figura \ref{fig:sol}, se espera recibir un código fuente
de una aplicación aproximable, donde previamente el usuario ha indicado, a
través de pragmas propios, qué funciones del código son tolerantes a errores; este
es transformado a una representación intermedia. El algoritmo que se pretende
desarrollar busca poder escoger cuáles versiones aproximadas de
las posibles que existen se ajustan para cumplir a cabalidad con el error
permitido y, de la mejor manera, con la priorización de recursos. Una vez
identificadas las versiones que serán utilizadas, se procederá a utilizar el
hardware específico que cuente con el soporte para las instrucciones aproximadas
correspondientes, para finalmente entregar una aplicación final aproximada. 



\subsection{Objetivos}

\subsubsection{Objetivo General}

Desarrollar una herramienta que, a partir de información sobre diferentes
versiones de secciones aproximadas de una aplicación tolerante a errores, pueda
determinar cuál combinación de versiones genera un mejor resultado en términos
de ahorro de recursos y el nivel de error máximo que un usuario estableció como
permitido. 


\subsubsection{Objetivos Específicos}

\begin{enumerate}
 \item Generar una representación del código de entrada que sea manipulable a
 partir de las anotaciones dadas por un usuario.
 
 \item Evaluar las versiones aproximadas de las secciones de una aplicación para
 saber cuál es su impacto en la aplicación final. 
 
 \item Desarrollar un algoritmo que permita, a partir de funciones indicadas por
 un usuario, la escogencia de secciones tolerantes a errores en una aplicación según
 las posibles versiones aproximadas existentes.
 
 \item Validar que la aplicación final aproximada cumpla con el funcionamiento
 de la aplicación original y las restricciones dadas por el usuario y por el la
 aplicación
\end{enumerate}


\section{Propuesta Metodológica}

\subsection{Tipificación del trabajo a realizar}

El proyecto se clasifica como un trabajo de investigación cualitativa, donde se
deben aplicar conocimientos en temas relacionados con sistemas operativos,
arquitectura de computadores, computación de alto rendimiento y compiladores.

\subsection{Descripción del proceso a realizar}

La Figura \ref{fig:proceso} resume el proceso que se realizará durante el proyecto.
Como se puede observar, el proyecto iniciará 
con una etapa de investigación sobre trabajos realizados
por varios autores en el área de computación aproximada, relacionados con la
caracterización de sistemas o aplicaciones en las cuales una o varias secciones
son aproximables. Se investigará sobre maneras de generar un compilador para un
cierto lenguaje y que permita el reconocimiento de pragmas o anotaciones en el código.


Seguidamente, se implementará un algoritmo que, a partir de una información dada
(gracias a una base de datos) determine qué combinación de funciones aproximadas
se deben colocar en un sistema en pipeline de tal forma que el resultado al
final de todas las etapas se mantenga en un nivel de error aceptable. Para esto
se tomará información de una base de datos del KIT sobre secciones aproximadas
independientes, para posteriormente evaluar el impacto final de cada una de
ellas en una aplicación completa.

Finalmente, se debe realizar la verificación de la aplicación aproximada final,
de forma que se garantice un cumplimiento en el nivel de error y una optimización
apropiada de los recursos. Para esto se realizarán simulaciones y pruebas
unitarias en plataformas como ModelSim. Si por alguna razón se detectaran
fallas, se revisará el algoritmo desarrollado con el fin de poder
corregirlo. 

La documentación del proyecto se trabajará a lo largo de todo el proceso de
desarrollo, de forma que al final se genere un artículo científico y demás
documentos propios de un trabajo final de graduación.

\begin{figure}[h!]
\centering
\begin{tikzpicture}[node distance=1cm, auto]  
\tikzset{
    mynode/.style={rectangle,rounded corners,draw=black, very thick, minimum
    size=3em, text centered},
    myarrow/.style={->, >=latex', shorten >=1pt, thick},
    mylabel/.style={text width=7em, text centered} 
}  
\node[mynode] (investigacion) {Investigación sobre antecedentes y trabajos previos};
\node[mynode, below=1cm of investigacion] (compilador) {Generación de compilador con pragmas propios};

\draw[myarrow] (investigacion.south)   -|  (compilador.north);

\node[mynode, below=1cm of compilador] (algoritmo) {\makecell{Desarrollo de algoritmo para evaluar impacto de\\ versiones aproximadas}};
 
 \draw[myarrow] (compilador.south)   -|  (algoritmo.north);
 
 
 \node[mynode, below=1cm of algoritmo] (verificacion) {Verificación de versones aproximadas finales};
 
  
   \draw[<->, >=latex', shorten >=1pt, thick]  (algoritmo.south) -- (verificacion.north); 
  
 
  
  \node[mynode, right=1.8cm of investigacion, dashed] (ini) {Documentación};

  \node[mynode, right=2cm of verificacion] (fin) {Documentación final}; 
  
 
 \draw[->, >=latex', shorten >=1pt, thick, dashed]  (ini.south) -|  (fin.north); 

\end{tikzpicture} 
\medskip
\caption{Proceso a realizar en este proyecto.} 
\label{fig:proceso}
\end{figure}

\section{Entregables del proyecto}

La tabla \ref{tab:entrega} presenta la asociación entre entregables y objetivos del proyectos, según los mencionados
anteriormente. 


\begin{table}[h!]
\begin{center}
\caption{Entregables del proyecto}
\resizebox{\textwidth}{!}{\begin{tabular}{|c|c|} 
 \hline
Objetivo	&Entregable \\ \hline \hline

\makecell{Generar una representación del código de entrada que sea \\ manipulable a
 partir de las anotaciones dadas por un usuario}	&Generación de compilador con pragmas propios \\ \hline
 \makecell{Evaluar las versiones aproximadas de las secciones de una \\ aplicación para
 saber cuál es su impacto en la aplicación final}	&\makecell{Desarrollo de algoritmo para evaluar impacto de\\ versiones aproximadas} \\ \hline
 \makecell{Desarrollar un algoritmo que permita, a partir de funciones indicadas \\ por
 un usuario, la escogencia de secciones tolerantes a errores en \\ una aplicación según
 las posibles versiones aproximadas existentes}	&\makecell{Desarrollo de algoritmo para evaluar impacto de\\ versiones aproximadas} \\ \hline
 \makecell{Validar que la aplicación final aproximada cumpla con el funcionamiento \\
 de la aplicación original y las restricciones dadas por el usuario y por el la \\
 aplicación}	&Documentación \\ \hline

\end{tabular}}
\label{tab:entrega}
\end{center}
\end{table}


\section{Antecedentes y trabajos relacionados}

En la actualidad, dada la gran cantidad de aplicaciones complejas (por ejemplo
sistemas GPS, reconocimiento de voz, etc.) la computación aproximada ayuda a
mantener una salida aceptable mientras se logra que ciertas métricas como tiempo
de respuesta o eficiencia energética se mejoren. En general, la computación 
aproximada provee la libertad de escoger entre un cierto nivel de error o
degradación de la calidad en la salida final de una aplicación (por ejemplo
ruido en la señal de la salida) para mejorar el consumo de energía, el área o el
tiempo de ejecución; esto sirve como herramienta a un investigador para que ajuste
una aplicación dada a las necesidades reales y específicas de esta. En la Figura
\ref{fig:ap} se muestra un esquema que puede ser aplicado a sistemas tolerantes
a errores para incluir en estos la computación aproximada \cite{xu2018approximate}.


\begin{figure}[h!]
\begin{center}
 \includegraphics[scale=0.3]{APframework}
 \caption{Un marco de trabajo para el uso de computación aproximada. Tomado de
 \cite{xu2018approximate}.} \label{fig:ap}
 \end{center}
\end{figure}




Los elementos clave de la Figura \ref{fig:ap} son \emph{kernels} aproximados,
los cuales representan la implementación (técnicas) de las funciones
aproximadas, estas puede ser realizadas a nivel de hardware o de software; la
identificación de la secciones tolerantes a errores y sus características
particulares (análisis de impacto); y el manejo de la calidad, el cual implica
una evaluación continua para determinar si la aplicación logra los
requerimientos deseados.

Como se mencionó, la computación aproximada puede ser implementada tanto a nivel
de software como de hardware. En software una implementación típica es a través
de \emph{Loop Perforation}, en la cual ciertos ciclos (usualmente con un patrón
dado, como por ejemplo las pares) no son computados, lo cual, por ejemplo en una
aplicación de cálculo numérico, reduciría la precisión del valor final
calculado. A nivel de hardware, se pueden utilizan módulos especializados, por
ejemplo aceleradores para programas aproximados utilizando redes neuronales.

El graduado de la carrera Ingeniería en Computadores Juan Carlos Cruz, realizó
un trabajo sobre la computación aproximada, donde él se dio la tarea de
caracterizar y calendarizar programas tolerantes a errores en una plataforma
multi-acelerador. Parte del actual proyecto busca partir de los resultados
generados por Cruz, de forma que se pueda utilizar el conocimiento generado
sobre secciones ya aproximadas, para poder desarrollar el algoritmo que
seleccionará cuál de todas ellas es la mejor según las especificaciones de un
usuario. 






% Referencias del Background y el Related Work
\bibliographystyle{sty/plainurl}
\bibliography{references}


\section{Anexos}

\subsection{Descripción de la empresa}

El Instituto Tecnológico de Karlsruhe (KIT) surge en 2009 a partir de la unión
de la Universidad de Karlsruhe, fundada en 1825 como Universidad Fridericiana, y
el Centro de Investigación de Karlsruhe. Se ubica en Karlsruhe, en el estado de
Baden-Wüttemberg, al suroeste de Alemania. 

El Instituto de Ingeniería en Computadores del KIT incluye grupos de trabajo
que abarcan los diferentes niveles de abstracción de sistemas computacionales.
En el \emph{Chair for Embedded Systems} (CES) se investigan diversos aspectos
relacionados con el diseño de sistemas embebidos, desde la confiabilidad de
circuitos hasta el manejo de potencia en sistemas multinúcleos.

El presente proyecto será desarrollado en el CES bajo la dirección del
M.Sc. Jorge Alberto Castro Godínez, ingeniero en electrónica, investigador y
estudiante de doctorado, quien es egresado del Tecnológico de Costa Rica y posee
más de dos años y medio como investigador en el Instituto Tecnológico de
Karlsruhe. 


\end{document}

